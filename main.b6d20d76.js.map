{"version":3,"sources":["modules/Game.class.js","scripts/main.js"],"names":["Game","initialState","length","every","row","Error","restart","status","result","state","map","arr","merge","isStateDifferent","updateGame","rotatedState","resultState","rotateMatrix","score","putNewNumber","cloneState","firstMoveMade","newState","push","console","log","column","mergedCells","forEach","cellElement","document","querySelector","classList","add","setTimeout","remove","isGameOver","isGameWon","cell","y","number","x","Math","floor","random","availableCell","getAvailableCell","randomCell","getRandomElement","generateNumber","directions","horizontal","forward","moveTiles","flat","includes","clockwise","_","colIndex","reverse","direction","filter","item","reduce","acc","idx","resLength","fill","module","exports","require","game","updateTable","querySelectorAll","rowElement","rowIndex","cellState","columnIndex","children","className","innerText","updateScore","updateButton","button","updateMessage","gameStatus","message","messageClass","idle","win","lose","update","getState","getScore","getFirstMoveMade","getStatus","addEventListener","start","e","actions","action","ArrowUp","moveUp","ArrowRight","moveRight","ArrowDown","moveDown","ArrowLeft","moveLeft","key","preventDefault"],"mappings":"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","file":"main.b6d20d76.js","sourceRoot":"../src","sourcesContent":["// 'use strict';\n\n// /**\n//  * This class represents the game.\n//  * Now it has a basic structure, that is needed for testing.\n//  * Feel free to add more props and methods if needed.\n//  */\n// class Game {\n//   /**\n//    * Creates a new game instance.\n//    *\n//    * @param {number[][]} initialState\n//    * The initial state of the board.\n//    * @default\n//    * [[0, 0, 0, 0],\n//    *  [0, 0, 0, 0],\n//    *  [0, 0, 0, 0],\n//    *  [0, 0, 0, 0]]\n//    *\n//    * If passed, the board will be initialized with the provided\n//    * initial state.\n//    */\n//   constructor(\n//     initialState = [\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//     ],\n//   ) {\n//     if (\n//       initialState.length === 4 &&\n//       initialState.every((row) => row.length === 4)\n//     ) {\n//       this.initialState = initialState;\n//       this.restart();\n//     } else {\n//       throw new Error('Initial state is not valid!');\n//     }\n//   }\n\n//   moveLeft() {\n//     if (this.status === 'playing') {\n//       const result = this.moveTiles(true, false);\n\n//       if (this.isStateDifferent(result.state)) {\n//         this.updateGame(result);\n//       }\n//     }\n//   }\n\n//   moveRight() {\n//     if (this.status === 'playing') {\n//       const result = this.moveTiles(true, true);\n\n//       if (this.isStateDifferent(result.state)) {\n//         this.updateGame(result);\n//       }\n//     }\n//   }\n\n//   moveUp() {\n//     if (this.status === 'playing') {\n//       const result = this.moveTiles(false, false);\n\n//       if (this.isStateDifferent(result.state)) {\n//         this.updateGame(result);\n//       }\n//     }\n//   }\n\n//   moveDown() {\n//     if (this.status === 'playing') {\n//       const result = this.moveTiles(false, true);\n\n//       if (this.isStateDifferent(result.state)) {\n//         this.updateGame(result);\n//       }\n//     }\n//   }\n\n//   /**\n//    * @returns {number}\n//    */\n//   getScore() {\n//     return this.score;\n//   }\n\n//   /**\n//    * @returns {number[][]}\n//    */\n//   getState() {\n//     return this.state;\n//   }\n\n//   /**\n//    * Returns the current game status.\n//    *\n//    * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n//    *\n//    * `idle` - the game has not started yet (the initial state);\n//    * `playing` - the game is in progress;\n//    * `win` - the game is won;\n//    * `lose` - the game is lost\n//    */\n//   getStatus() {\n//     return this.status;\n//   }\n\n//   /**\n//    * Starts the game.\n//    */\n//   start() {\n//     this.restart();\n//     this.status = 'playing';\n\n//     this.putNewNumber();\n//     this.putNewNumber();\n//   }\n\n//   /**\n//    * Resets the game.\n//    */\n//   restart() {\n//     this.state = this.cloneState(this.initialState);\n//     this.score = 0;\n//     this.status = 'idle';\n//     this.firstMoveMade = false;\n//   }\n\n//   // Add your own methods here\n//   cloneState(state) {\n//     const newState = [];\n\n//     for (let row = 0; row < state.length; row++) {\n//       newState.push([...state[row]]);\n//     }\n\n//     return newState;\n//   }\n\n//   isStateDifferent(newState) {\n//     for (let row = 0; row < this.state.length; row++) {\n//       for (let column = 0; column < this.state[row].length; column++) {\n//         if (this.state[row][column] !== newState[row][column]) {\n//           return true;\n//         }\n//       }\n//     }\n\n//     return false;\n//   }\n\n//   updateGame(result) {\n//     this.state = result.state;\n//     this.score += result.score;\n//     this.firstMoveMade = true;\n//     this.putNewNumber();\n\n//     result.mergedCells.forEach(({ row, column }) => {\n//       const cellElement = document.querySelector(\n//         `.field-cell--${this.state[row][column]}[data-row='${row}'][data-column='${column}']`,\n//       );\n\n//       if (cellElement) {\n//         cellElement.classList.add('merge');\n\n//         setTimeout(() => {\n//           cellElement.classList.remove('merge');\n//         }, 600);\n//       }\n//     });\n\n//     if (this.isGameOver()) {\n//       this.status = 'lose';\n//     } else if (this.isGameWon()) {\n//       this.status = 'win';\n//     }\n//   }\n\n//   getFirstMoveMade() {\n//     return this.firstMoveMade;\n//   }\n\n//   getAvailableCell() {\n//     const cell = [];\n\n//     this.state.forEach((row, y) => {\n//       row.forEach((number, x) => {\n//         if (!number) {\n//           cell.push({ x, y });\n//         }\n//       });\n//     });\n\n//     return cell;\n//   }\n\n//   getRandomElement(arr) {\n//     const randomIndex = Math.floor(Math.random() * arr.length);\n\n//     return arr[randomIndex];\n//   }\n\n//   generateNumber() {\n//     return Math.floor(Math.random() * 10) === 0 ? 4 : 2;\n//   }\n\n//   putNewNumber() {\n//     const availableCell = this.getAvailableCell();\n//     const randomCell = this.getRandomElement(availableCell);\n\n//     this.state[randomCell.y][randomCell.x] = this.generateNumber();\n//   }\n\n//   isGameOver() {\n//     if (this.getAvailableCell().length === 0) {\n//       const directions = [\n//         { horizontal: false, forward: false },\n//         { horizontal: true, forward: true },\n//         { horizontal: false, forward: true },\n//         { horizontal: true, forward: false },\n//       ];\n\n//       return directions.every(({ horizontal, forward }) => {\n//         const newState = this.moveTiles(horizontal, forward).state;\n\n//         return this.isStateDifferent(newState);\n//       });\n//     }\n\n//     return false;\n//   }\n\n//   isGameWon() {\n//     return this.state.flat().includes(2048);\n//   }\n\n//   getCellCoords(horizontal, firstCoord, position) {\n//     return horizontal\n//       ? { row: firstCoord, column: position }\n//       : { row: position, column: firstCoord };\n//   }\n\n//   moveTiles(horizontal, forward, addScore) {\n//     const state = this.cloneState(this.state);\n//     const mergedCells = [];\n//     let score = 0;\n\n//     const rowLength = state[0].length;\n//     const columnLength = state.length;\n//     let firstCoordLength;\n//     let secondCoordLength;\n\n//     if (horizontal) {\n//       firstCoordLength = columnLength;\n//       secondCoordLength = rowLength;\n//     } else {\n//       firstCoordLength = rowLength;\n//       secondCoordLength = columnLength;\n//     }\n\n//     let initialSecondCoord;\n//     let startOfStripe;\n//     let endOfStirpe;\n//     let step;\n\n//     if (forward) {\n//       initialSecondCoord = secondCoordLength - 2;\n//       startOfStripe = -1;\n//       endOfStirpe = secondCoordLength;\n//       step = 1;\n//     } else {\n//       initialSecondCoord = 1;\n//       startOfStripe = secondCoordLength;\n//       endOfStirpe = -1;\n//       step = -1;\n//     }\n\n//     for (let firstCoord = 0; firstCoord < firstCoordLength; firstCoord++) {\n//       const mergedInStripe = Array(secondCoordLength).fill(false);\n\n//       for (\n//         let secondCoord = initialSecondCoord;\n//         secondCoord !== startOfStripe;\n//         secondCoord -= step\n//       ) {\n//         let merged = false;\n//         let position = secondCoord;\n\n//         let currentCellCoords = this.getCellCoords(\n//           horizontal,\n//           firstCoord,\n//           position,\n//         );\n//         let nextCellCoords = this.getCellCoords(\n//           horizontal,\n//           firstCoord,\n//           position + step,\n//         );\n\n//         while (\n//           position + step !== endOfStirpe &&\n//           (state[nextCellCoords.row][nextCellCoords.column] === 0 ||\n//             (state[nextCellCoords.row][nextCellCoords.column] ===\n//               state[currentCellCoords.row][currentCellCoords.column] &&\n//               !mergedInStripe[position + step] &&\n//               !merged))\n//         ) {\n//           if (state[nextCellCoords.row][nextCellCoords.column] > 0) {\n//             merged = true;\n//             score += state[nextCellCoords.row][nextCellCoords.column] * 2;\n//           }\n\n//           state[nextCellCoords.row][nextCellCoords.column] +=\n//             state[currentCellCoords.row][currentCellCoords.column];\n//           state[currentCellCoords.row][currentCellCoords.column] = 0;\n//           position += step;\n\n//           currentCellCoords = this.getCellCoords(\n//             horizontal,\n//             firstCoord,\n//             position,\n//           );\n\n//           nextCellCoords = this.getCellCoords(\n//             horizontal,\n//             firstCoord,\n//             position + step,\n//           );\n//         }\n\n//         if (merged) {\n//           mergedInStripe[position] = true;\n\n//           mergedCells.push({\n//             row: firstCoord,\n//             colunm: position,\n//           });\n//         }\n//       }\n//     }\n\n//     return {\n//       state: state,\n//       score: score,\n//       mergedCells: mergedCells,\n//     };\n//   }\n// }\n\n// module.exports = Game;\n\n'use strict';\n\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */\nclass Game {\n  /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */\n  constructor(\n    initialState = [\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ],\n  ) {\n    if (\n      initialState.length === 4 &&\n      initialState.every((row) => row.length === 4)\n    ) {\n      this.initialState = initialState;\n      this.restart();\n    } else {\n      throw new Error('Initial state is not valid!');\n    }\n  }\n\n  moveLeft() {\n    if (this.status === 'playing') {\n      const result = this.state.map((arr) => this.merge(arr, 0));\n\n      if (this.isStateDifferent(result.state)) {\n        this.updateGame(result);\n      }\n    }\n  }\n\n  moveRight() {\n    if (this.status === 'playing') {\n      const result = this.state.map((arr) => this.merge(arr, 1));\n\n      if (this.isStateDifferent(result.state)) {\n        this.updateGame(result);\n      }\n    }\n  }\n\n  moveUp() {\n    if (this.status === 'playing') {\n      const rotatedState = this.rotateMatrix(this.state, 1);\n\n      const resultState = rotatedState.map((row) => this.merge(row, 1));\n\n      const result = this.rotateMatrix(resultState, 3);\n\n      if (this.isStateDifferent(result)) {\n        this.updateGame(result);\n      }\n    }\n  }\n\n  moveDown() {\n    if (this.status === 'playing') {\n      const rotatedState = this.rotateMatrix(this.state, 1);\n\n      const resultState = rotatedState.map((row) => this.merge(row, 0));\n\n      const result = this.rotateMatrix(resultState, 3);\n\n      if (this.isStateDifferent(result)) {\n        this.updateGame(result);\n      }\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  getScore() {\n    return this.score;\n  }\n\n  /**\n   * @returns {number[][]}\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */\n  getStatus() {\n    return this.status;\n  }\n\n  /**\n   * Starts the game.\n   */\n  start() {\n    this.restart();\n    this.status = 'playing';\n\n    this.putNewNumber();\n    this.putNewNumber();\n  }\n\n  /**\n   * Resets the game.\n   */\n  restart() {\n    this.state = this.cloneState(this.initialState);\n    this.score = 0;\n    this.status = 'idle';\n    this.firstMoveMade = false;\n  }\n\n  // Add your own methods here\n  cloneState(state) {\n    const newState = [];\n\n    for (let row = 0; row < state.length; row++) {\n      newState.push([...state[row]]);\n    }\n\n    console.log('test');\n\n    return newState;\n  }\n\n  isStateDifferent(newState) {\n    for (let row = 0; row < this.state.length; row++) {\n      for (let column = 0; column < this.state[row].length; column++) {\n        if (this.state[row][column] !== newState[row][column]) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  updateGame(result) {\n    this.state = result.state;\n    this.score += result.score;\n    this.firstMoveMade = true;\n    this.putNewNumber();\n\n    result.mergedCells.forEach(({ row, column }) => {\n      const cellElement = document.querySelector(\n        `.field-cell--${this.state[row][column]}[data-row='${row}'][data-column='${column}']`,\n      );\n\n      if (cellElement) {\n        cellElement.classList.add('merge');\n\n        setTimeout(() => {\n          cellElement.classList.remove('merge');\n        }, 600);\n      }\n    });\n\n    if (this.isGameOver()) {\n      this.status = 'lose';\n    } else if (this.isGameWon()) {\n      this.status = 'win';\n    }\n  }\n\n  getFirstMoveMade() {\n    return this.firstMoveMade;\n  }\n\n  getAvailableCell() {\n    const cell = [];\n\n    this.state.forEach((row, y) => {\n      row.forEach((number, x) => {\n        if (!number) {\n          cell.push({ x, y });\n        }\n      });\n    });\n\n    return cell;\n  }\n\n  getRandomElement(arr) {\n    const randomIndex = Math.floor(Math.random() * arr.length);\n\n    return arr[randomIndex];\n  }\n\n  generateNumber() {\n    return Math.floor(Math.random() * 10) === 0 ? 4 : 2;\n  }\n\n  putNewNumber() {\n    const availableCell = this.getAvailableCell();\n    const randomCell = this.getRandomElement(availableCell);\n\n    this.state[randomCell.y][randomCell.x] = this.generateNumber();\n  }\n\n  isGameOver() {\n    if (this.getAvailableCell().length === 0) {\n      const directions = [\n        { horizontal: false, forward: false },\n        { horizontal: true, forward: true },\n        { horizontal: false, forward: true },\n        { horizontal: true, forward: false },\n      ];\n\n      return directions.every(({ horizontal, forward }) => {\n        const newState = this.moveTiles(horizontal, forward).state;\n\n        return this.isStateDifferent(newState);\n      });\n    }\n\n    return false;\n  }\n\n  isGameWon() {\n    return this.state.flat().includes(2048);\n  }\n\n  rotateMatrix(arr, clockwise) {\n    if (clockwise) {\n      return arr.map((_, colIndex) => {\n        return arr.map((row) => row[colIndex]).reverse();\n      });\n    } else {\n      return arr.map((_, colIndex) => {\n        return arr.map((row) => row[row.length - 1 - colIndex]);\n      });\n    }\n  }\n\n  merge(arr, direction) {\n    const input = direction ? arr.reverse() : arr;\n    const result = input\n      .filter((item) => item)\n      .reduce((acc, item, idx) => {\n        if (acc[idx - 1] === item) {\n          acc[acc.length - 1] += item;\n          this.score += acc[acc.length - 1];\n        } else {\n          acc.push(item);\n        }\n\n        return acc;\n      }, []);\n\n    const resLength = result.length;\n\n    result.length = arr.length;\n    result.fill(0, resLength, result.length);\n\n    return direction ? result.reverse() : result;\n  }\n}\n\nmodule.exports = Game;\n","'use strict';\n\n// Uncomment the next lines to use your game instance in the browser\n// const Game = require('../modules/Game.class');\n// const game = new Game();\n\n// Write your code here\n\n// class Game {\n//   constructor() {\n//     this.state = [\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//     ];\n\n//     this.score = 0;\n//     this.firstMoveMade = false;\n//     this.gameOver = false;\n\n//     this.startMessage = document.querySelector('.message-start');\n//     this.winMessage = document.querySelector('.message-win');\n//     this.loseMessage = document.querySelector('.message-lose');\n//     this.buttonStart = document.querySelector('.start');\n//     this.scoreDisplay = document.querySelector('.game-score');\n\n//     this.buttonStart.addEventListener('click', () => this.start());\n//   }\n\n//   handler() {\n//     document.addEventListener('keydown', (e) => this.handleKeydown(e));\n//   }\n//   handleKeydown(e) {\n//     if (this.gameOver) {\n//       return;\n//     }\n\n//     if (e.key === 'ArrowLeft') {\n//       this.moveLeft();\n//     } else if (e.key === 'ArrowRight') {\n//       this.moveRight();\n//     } else if (e.key === 'ArrowUp') {\n//       this.moveUp();\n//     } else if (e.key === 'ArrowDown') {\n//       this.moveDown();\n//     }\n\n//     if (!this.firstMoveMade) {\n//       this.firstMoveMade = true;\n//       this.buttonStart.textContent = 'Restart';\n//     }\n\n//     this.checkWin();\n//     this.checkGameOver();\n//   }\n\n//   generateNumber() {\n//     const randomValue = Math.random();\n\n//     return randomValue < 0.9 ? 2 : 4;\n//   }\n\n//   pushGenerateNumber() {\n//     const availableIndexes = [[], [], [], []];\n\n//     this.state.forEach((array, i) => {\n//       array.forEach((number, index) => {\n//         if (!number) {\n//           availableIndexes[i].push(index);\n//         }\n//       });\n//     });\n\n//     const availableArray = [];\n\n//     availableIndexes.forEach((arr, index) => {\n//       if (arr.length) {\n//         availableArray.push(index);\n//       }\n//     });\n\n//     const array = this.getRandomElement(availableArray);\n\n//     const number = this.getRandomElement(availableIndexes[array]);\n\n//     this.state[array][number] = this.generateNumber();\n//     this.render();\n//   }\n\n//   getRandomElement(arr) {\n//     const randomIndex = Math.floor(Math.random() * arr.length);\n\n//     return arr[randomIndex];\n//   }\n\n//   init() {\n//     this.pushGenerateNumber();\n//     this.pushGenerateNumber();\n//     this.render();\n//   }\n\n//   moveLeft() {\n//     this.state = this.state.map((arr) => this.merge(arr, 0));\n\n//     this.init();\n//   }\n\n//   moveRight() {\n//     this.state = this.state.map((arr) => this.merge(arr, 1));\n\n//     this.init();\n//   }\n\n//   rotateMatrix(arr, clockwise) {\n//     if (clockwise) {\n//       return arr.map((_, colIndex) => {\n//         return arr.map((row) => row[colIndex]).reverse();\n//       });\n//     } else {\n//       return arr.map((_, colIndex) => {\n//         return arr.map((row) => row[row.length - 1 - colIndex]);\n//       });\n//     }\n//   }\n\n//   moveUp() {\n//     this.state = this.rotateMatrix(this.state, 1);\n//     this.state = this.state.map((arr) => this.merge(arr, 1));\n//     this.state = this.rotateMatrix(this.state, 0);\n\n//     this.init();\n//   }\n\n//   moveDown() {\n//     this.state = this.rotateMatrix(this.state, 1);\n//     this.state = this.state.map((arr) => this.merge(arr, 0));\n//     this.state = this.rotateMatrix(this.state, 0);\n\n//     this.init();\n//   }\n\n//   merge(arr, direction) {\n//     const input = direction ? arr.reverse() : arr;\n//     const result = input\n//       .filter((item) => item)\n//       .reduce((acc, item, idx) => {\n//         if (acc[idx - 1] === item) {\n//           acc[acc.length - 1] += item;\n//           this.score += acc[acc.length - 1];\n//         } else {\n//           acc.push(item);\n//         }\n\n//         return acc;\n//       }, []);\n\n//     const resLength = result.length;\n\n//     result.length = arr.length;\n//     result.fill(0, resLength, result.length);\n\n//     return direction ? result.reverse() : result;\n//   }\n\n//   checkWin() {\n//     for (const row of this.state) {\n//       if (row.includes(2048)) {\n//         this.showMessage(this.winMessage);\n//         this.gameOver = true;\n\n//         return true;\n//       }\n//     }\n\n//     return false;\n//   }\n\n//   checkGameOver() {\n//     for (const row of this.state) {\n//       if (row.includes(0)) {\n//         return false;\n//       }\n//     }\n\n//     for (let i = 0; i < this.state.length; i++) {\n//       for (let j = 0; j < this.state[i].length; j++) {\n//         if (\n//           (i < this.state.length - 1 &&\n//             this.state[i][j] === this.state[i + 1][j]) ||\n//           (j < this.state[i].length - 1 &&\n//             this.state[i][j] === this.state[i][j + 1])\n//         ) {\n//           return false;\n//         }\n//       }\n//     }\n\n//     this.showMessage(this.loseMessage);\n//     this.gameOver = true;\n\n//     return true;\n//   }\n\n//   showMessage(messageElement) {\n//     this.startMessage.classList.add('hidden');\n//     this.winMessage.classList.add('hidden');\n//     this.loseMessage.classList.add('hidden');\n//     messageElement.classList.remove('hidden');\n//   }\n\n//   getState() {}\n//   getScore() {}\n//   getStatus() {}\n//   start() {\n//     this.state = [\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//     ];\n//     this.score = 0;\n//     this.firstMoveMade = false;\n//     this.gameOver = false;\n\n//     this.scoreDisplay.textContent = this.score;\n//     this.showMessage(this.startMessage);\n//     this.buttonStart.textContent = 'Start';\n//     this.init();\n//   }\n//   restart() {}\n//   render() {\n//     const tbody = document.querySelector('tbody');\n\n//     this.state.forEach((row) => {\n//       const tr = document.querySelector('tr');\n\n//       row.forEach((cell) => {\n//         const td = document.querySelector('td');\n\n//         td.textContent = cell || '';\n//         tr.appendChild(td);\n\n//         if (!cell) {\n//           td.className = 'field-cell';\n//         }\n//         td.classList.add(`field-cell--${cell}`);\n//       });\n//       tbody.appendChild(tr);\n//     });\n\n//     this.scoreDisplay.textContent = this.score;\n//   }\n// }\n\n// const game = new Game();\n\n// game.init();\n// game.handler();\n\n'use strict';\n\n// Uncomment the next lines to use your game instance in the browser\nconst Game = require('../modules/Game.class');\nconst game = new Game();\n\n// Write your code here\nfunction updateTable(state) {\n  const fieldRows = document.querySelectorAll('.field-row');\n\n  fieldRows.forEach((rowElement, rowIndex) => {\n    const rowState = state[rowIndex];\n\n    rowState.forEach((cellState, columnIndex) => {\n      const cellElement = rowElement.children[columnIndex];\n\n      cellElement.className = `field-cell field-cell--${cellState}`;\n      cellElement.innerText = cellState > 0 ? cellState : '';\n\n      if (cellState > 0) {\n        cellElement.classList.add('merge');\n\n        setTimeout(() => cellElement.classList.remove('merge'), 600);\n      }\n    });\n  });\n}\n\nfunction updateScore(score) {\n  document.querySelector('.game-score').innerText = score;\n}\n\nfunction updateButton(firstMoveMade) {\n  if (firstMoveMade) {\n    button.className = 'button restart';\n    button.innerText = 'Restart';\n  } else {\n    button.className = 'button start';\n    button.innerText = 'Start';\n  }\n}\n\nfunction updateMessage(gameStatus) {\n  const messageClasses = {\n    idle: 'message-start',\n    win: 'message-win',\n    lose: 'message-lose',\n  };\n\n  document.querySelectorAll('.message').forEach((message) => {\n    message.classList.add('hidden');\n  });\n\n  const messageClass = messageClasses[gameStatus];\n\n  if (messageClass) {\n    document.querySelector(`.${messageClass}`).classList.remove('hidden');\n  }\n}\n\nfunction update() {\n  updateTable(game.getState());\n  updateScore(game.getScore());\n  updateButton(game.getFirstMoveMade());\n  updateMessage(game.getStatus());\n}\n\nconst button = document.querySelector('.button');\n\nbutton.addEventListener('click', () => {\n  switch (button.innerText) {\n    case 'Start':\n      game.start();\n      break;\n    case 'Restart':\n      game.restart();\n  }\n\n  console.log('test');\n\n  update();\n});\n\ndocument.addEventListener('keydown', (e) => {\n  const actions = {\n    ArrowUp: () => game.moveUp(),\n    ArrowRight: () => game.moveRight(),\n    ArrowDown: () => game.moveDown(),\n    ArrowLeft: () => game.moveLeft(),\n  };\n\n  const action = actions[e.key];\n\n  if (action) {\n    e.preventDefault();\n    action();\n  }\n\n  update();\n});\n"]}